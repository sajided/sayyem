import { NextResponse } from 'next/server';
import Order from '../../../models/Order';
import { dbConnect } from '../../../lib/db';

export async function POST(req){
  await dbConnect();
  const body = await req.json().catch(() => ({}));

  const {
    items, customer, advanceDue = 0, isPreorder = true,
    // any other fields pass-through:
    metadata = {}, payment = {}, isPreOrder: isPreorder, preOrderAdvanceAmount: advanceDue
  } = body;

  const name = customer?.name || body?.name || null;
  const phone = customer?.phone || body?.phone || null;
  const email = customer?.email || body?.email || null;
  const address = customer?.address || body?.address || null;
  const city = customer?.city || body?.city || null;

  if(!phone){
    return NextResponse.json({ ok:false, error: 'Phone is required' }, { status: 400 });
  }

  const order = await Order.create({
    items,
    name, phone, email,
    address, city,
    customer,
    isPreorder: !!isPreorder,
    preorder: {
      advanceDue: Number(advanceDue || 0),
      advancePaid: 0,
      advancePaidAt: null,
      verified: false,
      uddoktaInvoiceId: null,
      uddoktaStatus: 'PENDING',
      txnId: null,
    },
    status: 'PENDING',
    metadata
  });

  // If client already created an invoice upstream, store its id (but do not mark as paid)
  const hintedInvoiceId = payment?.invoice_id || payment?.invoiceId || metadata?.invoice_id || metadata?.invoiceId || null;
  if(hintedInvoiceId){
    order.preorder.uddoktaInvoiceId = hintedInvoiceId;
    await order.save();
  }

  return NextResponse.json({ ok:true, orderId: order._id });
}
